{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "(50 pts) Implement a hash for text. Given a string as input, construct a hash with\n",
    "words as keys, and word counts as values.\n",
    "\n",
    "<br>Your implementation should include:\n",
    "\n",
    "<br> a hash function that has good properties for text\n",
    "<br> storage and collision management using linked lists\n",
    "<br> operations: insert(key,value), delete(key), increase(key), find(key), list-all-keys\n",
    "<br> each word (key) can only appear once in the datastructure\n",
    "<br><br><br>Output the list of words together with their counts on an output file. For this problem,\n",
    "you cannot use built-in-language datastuctures that can index by strings (like hash\n",
    "tables or dictionaries). Use a language that easily implements linked lists.\n",
    "<br>You can test your code on “Alice in Wonderland” by Lewis Carroll, at\n",
    "http://www.ccs.neu.edu/home/vip/teach/Algorithms/\\7_hash_RBtree_simpleDS/\n",
    "<br>hw_hash_RBtree/alice_in_wonderland.txt.\n",
    "<br>The test file used by TA will probably be shorter.\n",
    "<br><br>(Extra Credit) Find a way to record not only word counts, but also the positions in\n",
    "text. For each word, besides the count value, built a linked list with positions in the\n",
    "given text. Output this list together with the count."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "class Node:\n",
    "    def __init__(self, keyval=None, dataval=None):\n",
    "        self.keyval = keyval\n",
    "        self.dataval = dataval\n",
    "        self.nextval = None\n",
    "\n",
    "class SLinkedList:\n",
    "    def __init__(self):\n",
    "        self.headval = None\n",
    "            \n",
    "\n",
    "    def listprint(self):\n",
    "        printval = self.headval\n",
    "        while printval is not None:\n",
    "            print (printval.dataval, printval.keyval)\n",
    "            printval = printval.nextval\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "## hash function\n",
    "\n",
    "class HashClass:\n",
    "    def __init__(self, size):     \n",
    "        self.size = size\n",
    "        self.buckets = [None] * self.size\n",
    "\n",
    "    def hashit(self,key):\n",
    "        return len(key) % self.size\n",
    "\n",
    "\n",
    "        \n",
    "    \n",
    "    def insert_key(self,key):\n",
    "        hashed = self.hashit(key)\n",
    "\n",
    "        if self.buckets[hashed] == None:\n",
    "            list1 = SLinkedList()\n",
    "            list1.headval = Node(key, 1)\n",
    "            \n",
    "            #what we should be doing is immediately creating a linked list\n",
    "            self.buckets[hashed] = list1\n",
    "        \n",
    "        else:\n",
    "            list2 = self.buckets[hashed]\n",
    "            \n",
    "            # need to check if the key value is in the linked list\n",
    "            \n",
    "            key_bool = False\n",
    "            lastnode = False\n",
    "            node = list2.headval\n",
    "            \n",
    "            # add value to key that already exists\n",
    "            while True:                \n",
    "                if node.keyval == key:\n",
    "                    \n",
    "                    ## update the count\n",
    "                    node.dataval += 1\n",
    "                    key = True\n",
    "                    break    \n",
    "                elif node.nextval == None and node.keyval != key:\n",
    "                    node.nextval = Node(key, 1)\n",
    "                    break\n",
    "                node = node.nextval\n",
    "            list2.listprint()\n",
    "                \n",
    "\n",
    "                    \n",
    "                \n",
    "                \n",
    "                \n",
    "\n",
    "\n",
    "        \n",
    "    \n",
    "    def delete_key(self, key):\n",
    "        hashed = self.hashit(key)\n",
    "        linked = self.buckets[hashed]\n",
    "        \n",
    "        node_prev = None\n",
    "        node = linked.headval\n",
    "        while True:        \n",
    "            if node.keyval == key:\n",
    "                if node_prev == None:\n",
    "                    self.buckets[hashed] = node.nextval\n",
    "                else:\n",
    "                    node_prev.nextval = node.nextval\n",
    "                break      \n",
    "\n",
    "            node_prev = node    \n",
    "            node = node.nextval\n",
    "        \n",
    "        \n",
    "        linked.listprint()\n",
    "            \n",
    "        \n",
    "    \n",
    "    \n",
    "    def find(self, key):\n",
    "        hashed = self.hashit(key)\n",
    "        \n",
    "        linked = self.buckets[hashed]\n",
    "        \n",
    "        if linked:\n",
    "            node = linked.headval\n",
    "            while True:\n",
    "                if node.keyval == key:\n",
    "                    return node\n",
    "                \n",
    "                node = node.nextval\n",
    "                if node == None:\n",
    "                    break\n",
    "                    \n",
    "    def list_all(self):\n",
    "\n",
    "    \n",
    "        for bucket in self.buckets:\n",
    "            if not None:\n",
    "                bucket.listprint()\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2 sad\n",
      "2 sad\n",
      "1 bad\n",
      "2 sad\n",
      "2 bad\n"
     ]
    }
   ],
   "source": [
    "## we are going to need to go through each piece of text in the text file \n",
    "\n",
    "##then we are going to need to hash it\n",
    "\n",
    "# go through each of the words and insert it \n",
    "\n",
    "\n",
    "ha = HashClass(7)\n",
    "\n",
    "ha.insert_key('sad')\n",
    "ha.insert_key('sad')\n",
    "ha.insert_key('bad')\n",
    "ha.insert_key('bad')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 129,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2 sad\n"
     ]
    }
   ],
   "source": [
    "ha.delete_key('bad')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<__main__.Node at 0x7fa7a1c6e430>"
      ]
     },
     "execution_count": 130,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ha.find('sad')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " (50points) Implement a red-black tree, including binary-search-tree operations sort,\n",
    "search, min, max, successor, predecessor and specific red-black procedures rotation,\n",
    "insert, delete. The delete implementation is Extra Credit (but highly recommended).\n",
    "Your code should take the input array of numbers from a file and build a red-black\n",
    "tree with this input by sequence of “inserts”. Then interactively ask the user for an\n",
    "operational command like “insert x” or “sort” or “search x” etc, on each of which your\n",
    "code rearranges the tree and if needed produces an output. After each operation also\n",
    "print out the height of the tree.\n",
    "You can use any mechanism to implement the tree, for example with pointers and\n",
    "struct objects in C++, or with arrays of indices that represent links between parent\n",
    "and children. You cannot use any tree built-in structure in any language."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "( Implement Skiplists 50 points). Study the skiplist data structure and operations.\n",
    "They are used for sorting values, but in a datastructure more effficient than lists or\n",
    "arrays, and more guaranteed than binary search trees. Review Slides skiplists.pdf\n",
    "1\n",
    "and Visualizer https://people.ok.ubc.ca/ylucet/DS/SkipList.html. The demo\n",
    "will be a sequence of operations (asked by TA) such as for example\n",
    "insert 20, insert 40, insert 10, insert 20, insert 5, insert 80, delete 20, insert 100, insert\n",
    "20, insert 30, delete 5, insert 50, lookup 80, etc"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 301,
   "metadata": {},
   "outputs": [],
   "source": [
    "## implementing skip list\n",
    "\n",
    "#insert, delete, loopup \n",
    "\n",
    "import random\n",
    "\n",
    "         \n",
    "    \n",
    "\n",
    "# we can use the same linked list from before\n",
    "\n",
    "\n",
    "class SLinkedList:\n",
    "    def __init__(self):\n",
    "        self.headval = None\n",
    "    \n",
    "    def insert_node(self, node):\n",
    "        \n",
    "        curr_node = self.headval\n",
    "        \n",
    "        while True:\n",
    "            if self.headval == None:\n",
    "                self.headval = node\n",
    "                return\n",
    "            \n",
    "            # we should see if insert node actually can be faster\n",
    "            \n",
    "            \n",
    "            if curr_node.data < node.data and curr_node.nextval >= node.data:\n",
    "                old_next = curr_node.nextval\n",
    "                curr_node.nextval = node\n",
    "                node.previousval = curr_node\n",
    "                node.nextval = old_next\n",
    "                old_next.previousval = node\n",
    "                break\n",
    "            elif curr_node.data >= node.data and curr_node == self.headval:\n",
    "                old_next = self.headval\n",
    "                self.headval = node\n",
    "                node.nextval = old_next\n",
    "                old_next.previousval = node\n",
    "                break\n",
    "            elif curr_node.data < node.data and curr_node.nextval == None:\n",
    "                old_next = curr_node.nextval\n",
    "                curr_node.nextval = node\n",
    "                node.previousval = curr_node\n",
    "                old_next.previousval = node\n",
    "                node.nextval = old_next\n",
    "                break\n",
    "            curr_node = curr_node.nextval\n",
    "            \n",
    "    def listprint(self):\n",
    "        printval = self.headval\n",
    "        printable = []\n",
    "        while printval is not None:\n",
    "\n",
    "            printable.append(printval.data)\n",
    "            printval = printval.nextval\n",
    "                \n",
    "        print(printable)\n",
    "\n",
    "class Node:\n",
    "    def __init__(self, data=None):\n",
    "        self.data = data\n",
    "        self.nextval = None\n",
    "        self.previousval = None\n",
    "        # if promoted we should keep track of this value\n",
    "        self.belowval = None\n",
    "    \n",
    "    def promote(self):\n",
    "        return random.random() < .5\n",
    " \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    \n",
    "\n",
    "class SkipList:\n",
    "    def __init__(self):\n",
    "        \n",
    "        # head must be the top right node\n",
    "        \n",
    "        self.levels = []\n",
    "        \n",
    "        # each level has a head\n",
    "\n",
    "    \n",
    "    def insert(self, data):\n",
    "        # if head is None must set as head node\n",
    "        # dont forget checking if the node is greater or smaller \n",
    "        # check the levels \n",
    "        \n",
    "        # need to include the down pointer\n",
    "        \n",
    "        node = Node(data)\n",
    "        \n",
    "        if len(self.levels) == 0:\n",
    "            print(True)\n",
    "            \n",
    "            newList = SLinkedList()\n",
    "            newList.headval = node\n",
    "            \n",
    "            self.levels.append(newList)\n",
    "            \n",
    "            # need to promote the node \n",
    "            \n",
    "            while True:\n",
    "                \n",
    "                flip = node.promote()\n",
    "                print('flip', flip)\n",
    "                \n",
    "                if flip == False:\n",
    "                    break\n",
    "                \n",
    "                # time to promote \n",
    "                newList = SLinkedList()\n",
    "                newList.headval = Node(node.data)\n",
    "                newList.headval.belowval = node\n",
    "                self.levels.append(newList)\n",
    "                \n",
    "        \n",
    "        else:\n",
    "            level = 0\n",
    "            \n",
    "            \n",
    "            \n",
    "            while True:\n",
    "                \n",
    "                \n",
    "                if level + 1 > len(self.levels):\n",
    "                    newList = SLinkedList()\n",
    "                    self.levels.append(newList)\n",
    "\n",
    "                    \n",
    "                \n",
    "                current = self.levels[level]\n",
    "                \n",
    "                current.insert_node(node)\n",
    "                \n",
    "                if node.promote() == False:\n",
    "                    break\n",
    "                    \n",
    "                level += 1\n",
    "                \n",
    "                \n",
    "                \n",
    "            \n",
    "        \n",
    "      \n",
    "    def delete(self, data):\n",
    "        \n",
    "\n",
    "        if self.lookup(data, True) == None:\n",
    "            print(\"tis none\")\n",
    "            return None \n",
    "\n",
    "        node = self.lookup(data, True)[0]\n",
    "        \n",
    "        level = self.lookup(data, True)[1]\n",
    "        level = self.levels[level]\n",
    "        \n",
    "        while True:\n",
    "            prev = node.previousval\n",
    "            nex = node.nextval\n",
    "            below = node.belowval\n",
    "            print(prev)\n",
    "            print(nex)\n",
    "            print(below)\n",
    "            \n",
    "            if prev != None and nex != None:\n",
    "                prev.nextval = nex\n",
    "                nex.previousval = prev\n",
    "                break\n",
    "            elif prev == None and nex != None:\n",
    "                level.headval = nex\n",
    "                break\n",
    "            elif prev != None and nex == None:\n",
    "                prev.nextval = None\n",
    "                break\n",
    "            elif prev == None and nex == None and below == None:\n",
    "                break\n",
    "            else:\n",
    "                \n",
    "                if below:\n",
    "                    node = below\n",
    "                else:\n",
    "                    break\n",
    "                \n",
    "            \n",
    "        \n",
    "        \n",
    "    \n",
    "    \n",
    "    def lookup(self, data, delete=False):\n",
    "        \n",
    "        # start at the top function\n",
    "        \n",
    "        current = -1\n",
    "        curr_node = self.levels[current].headval\n",
    "        \n",
    "        while True:\n",
    "            \n",
    "            # need to take care if nextval greater\n",
    "            \n",
    "            if curr_node.data == data:\n",
    "            \n",
    "                if delete == False:\n",
    "                    return curr_node\n",
    "                else:\n",
    "                    return (curr_node, -1*current - 1)\n",
    "            elif curr_node.data > data:\n",
    "                if curr_node.previousval != None:\n",
    "                    \n",
    "                    curr_node = curr_node.previousval.belowval\n",
    "                else:\n",
    "                    return None\n",
    "                if curr_node == None:\n",
    "                    return None\n",
    "            elif curr_node.nextval == None and -1* len(self.levels) != current:\n",
    "                current -= 1\n",
    "            else:\n",
    "                curr_node = curr_node.nextval\n",
    "        \n",
    "        \n",
    "        \n",
    "        \n",
    "    \n",
    "    def print_skip_list(self):\n",
    "        \n",
    "        for level in range(0, len(self.levels)):\n",
    "            print('Level: ', level)\n",
    "            self.levels[level].listprint()\n",
    "            \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 302,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n",
      "flip True\n",
      "flip False\n",
      "Level:  0\n",
      "[15, 31]\n",
      "Level:  1\n",
      "[15, 31]\n",
      "Level:  2\n",
      "[15, 31]\n"
     ]
    }
   ],
   "source": [
    "skip = SkipList()\n",
    "\n",
    "\n",
    "# shouldnt be inser\n",
    "\n",
    "skip.insert(31)\n",
    "\n",
    "skip.insert(15)\n",
    "skip.print_skip_list()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 303,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<__main__.Node at 0x7fa7a34b8070>"
      ]
     },
     "execution_count": 303,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "skip.lookup(31)\n",
    "# skip.delete(31)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 304,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<__main__.Node object at 0x7fa7a380a130>\n",
      "None\n",
      "<__main__.Node object at 0x7fa7a34fca30>\n"
     ]
    }
   ],
   "source": [
    "skip.delete(31)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "4. (DP problem; Extra credit 50 pts) The int[] bag describes a bag of non-negative\n",
    "integers. A bag is the same thing as a set, only it may contain repeated elements. The\n",
    "order of elements in a bag does not matter. Given two bags A and B, we say that\n",
    "A is a sub-bag of B if A can be obtained by erasing zero or more elements from B.\n",
    "The weight of a bag is the sum of its elements. Examples: The bags (1, 2, 1, 3, 1) and\n",
    "(3, 1, 1, 1, 2) are the same, but different from the bag (1, 2, 3, 3). Bags (1, 2) and (3, 1, 1)\n",
    "are sub-bags of the bag (1, 2, 1, 3, 1), but bag (1, 2, 2) is not. The weight of the bag\n",
    "(1, 2, 1, 3, 1) is 1 + 2 + 1 + 3 + 1 = 8. The bag will contain less than 50 elements, and\n",
    "each element will be less than 10,000. Write a method that will compute how many\n",
    "sub-bags of bag have a prime weight. Your program should not use more than 3M\n",
    "memory, and should pass the following"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
